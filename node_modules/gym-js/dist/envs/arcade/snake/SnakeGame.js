"use strict";
// import codependency from "codependency";
// var requirePeer = codependency.register(module);
// var Phaser = requirePeer("phaser");
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Phaser = require("phaser");
var Food_1 = require("./Food");
var utils_1 = require("../../../utils");
var UP = 0;
var DOWN = 1;
var LEFT = 2;
var RIGHT = 3;
/** @ignore */
var SnakeBody = /** @class */ (function (_super) {
    __extends(SnakeBody, _super);
    function SnakeBody(scene, x, y, width, height) {
        var _this = _super.call(this, {
            key: 'GameScene',
        }) || this;
        _this.headPosition = new Phaser.Geom.Point(x, y);
        _this.body = scene.add.group();
        _this.head = _this.body.create(x * 16, y * 16, 'block');
        _this.head.setOrigin(0);
        _this.alive = true;
        _this.speed = 100;
        _this.moveTime = 0;
        _this.tail = new Phaser.Geom.Point(x, y);
        _this.heading = RIGHT;
        _this.direction = RIGHT;
        _this.grow();
        _this.grow();
        _this.gameWidth = width;
        _this.gameHeight = height;
        return _this;
    }
    SnakeBody.prototype.update = function (time) {
        if (time >= this.moveTime) {
            return this.move(time);
        }
    };
    SnakeBody.prototype.faceLeft = function () {
        if (this.direction === UP || this.direction === DOWN) {
            this.heading = LEFT;
        }
    };
    SnakeBody.prototype.faceRight = function () {
        if (this.direction === UP || this.direction === DOWN) {
            this.heading = RIGHT;
        }
    };
    SnakeBody.prototype.faceUp = function () {
        if (this.direction === LEFT || this.direction === RIGHT) {
            this.heading = UP;
        }
    };
    SnakeBody.prototype.faceDown = function () {
        if (this.direction === LEFT || this.direction === RIGHT) {
            this.heading = DOWN;
        }
    };
    SnakeBody.prototype.move = function (time) {
        /**
         * Based on the heading property (which is the direction the pgroup pressed)
         * we update the headPosition value accordingly.
         *
         * The Math.wrap call allow the snake to wrap around the screen, so when
         * it goes off any of the sides it re-appears on the other.
         */
        switch (this.heading) {
            case LEFT:
                this.headPosition.x = Phaser.Math.Wrap(this.headPosition.x - 1, 0, this.gameWidth);
                break;
            case RIGHT:
                this.headPosition.x = Phaser.Math.Wrap(this.headPosition.x + 1, 0, this.gameWidth);
                break;
            case UP:
                this.headPosition.y = Phaser.Math.Wrap(this.headPosition.y - 1, 0, this.gameHeight);
                break;
            case DOWN:
                this.headPosition.y = Phaser.Math.Wrap(this.headPosition.y + 1, 0, this.gameHeight);
                break;
        }
        this.direction = this.heading;
        //  Update the body segments and place the last coordinate into this.tail
        Phaser.Actions.ShiftPosition(this.body.getChildren(), this.headPosition.x * 16, this.headPosition.y * 16, 1, this.tail);
        //  Check to see if any of the body pieces have the same x/y as the head
        //  If they do, the head ran into the body
        var hitBody = Phaser.Actions.GetFirst(this.body.getChildren(), { x: this.head.x, y: this.head.y }, 1);
        if (hitBody) {
            this.alive = false;
            return false;
        }
        else {
            //  Update the timer ready for the next movement
            this.moveTime = time + this.speed;
            return true;
        }
    };
    SnakeBody.prototype.grow = function () {
        var newPart = this.body.create(this.tail.x, this.tail.y, 'block');
        newPart.setOrigin(0);
    };
    SnakeBody.prototype.collideWithFood = function (food) {
        if (this.head.x === food.x && this.head.y === food.y) {
            this.grow();
            food.eat();
            //  For every 5 items of food eaten we'll increase the snake speed a little
            if (this.speed > 20 && food.total % 5 === 0) {
                this.speed -= 5;
            }
            return true;
        }
        else {
            return false;
        }
    };
    SnakeBody.prototype.updateGrid = function (grid) {
        //  Remove all body pieces from valid positions list
        this.body.children.each(function (segment) {
            var bx = segment.x / 16;
            var by = segment.y / 16;
            grid[by][bx] = false;
        });
        return grid;
    };
    return SnakeBody;
}(Phaser.Scene));
/** @ignore */
var SnakeGame = /** @class */ (function (_super) {
    __extends(SnakeGame, _super);
    function SnakeGame() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.action = 0;
        _this.done = false;
        _this.mode = 'bot';
        _this.reward = 0;
        _this.random = new Phaser.Math.RandomDataGenerator();
        return _this;
    }
    SnakeGame.prototype.preload = function () {
        // This is still a fragile state of affairs, but I must decide how to handle images better so they load if you import gym
        this.load.image('block', 'https://raw.githubusercontent.com/Tom2718/gym.js/master/src/envs/arcade/snake/block.png');
    };
    SnakeGame.prototype.create = function () {
        this.gameWidth = Math.floor(Number(this.game.config.width) / 16);
        this.gameHeight = Math.floor(Number(this.game.config.height) / 16);
        this.food = new Food_1.default(this, utils_1.randint(this.gameWidth), utils_1.randint(this.gameHeight));
        this.snake = new SnakeBody(this, utils_1.randint(this.gameWidth), utils_1.randint(this.gameHeight), this.gameWidth, this.gameHeight);
        // Create keyboard controls
        if (this.mode === 'interactive') {
            this.cursors = this.input.keyboard.createCursorKeys();
        }
    };
    SnakeGame.prototype.update = function (time, delta) {
        if (!this.snake.alive) {
            this.done = true;
            this.reward--;
            return;
        }
        /**
         * Check which key is pressed, and then change the direction the snake
         * is heading based on that. The checks ensure you don't double-back
         * on yourself, for example if you're moving to the right and you press
         * the LEFT cursor, it ignores it, because the only valid directions you
         * can move in at that time is up and down.
         */
        if (this.mode === 'interactive') {
            if (this.cursors.left.isDown) {
                this.snake.faceLeft();
            }
            else if (this.cursors.right.isDown) {
                this.snake.faceRight();
            }
            else if (this.cursors.up.isDown) {
                this.snake.faceUp();
            }
            else if (this.cursors.down.isDown) {
                this.snake.faceDown();
            }
        }
        else {
            if (this.action === 0) {
                this.snake.faceLeft();
            }
            else if (this.action === 1) {
                this.snake.faceUp();
            }
            else if (this.action === 2) {
                this.snake.faceRight();
            }
            else if (this.action === 3) {
                this.snake.faceDown();
            }
        }
        if (this.snake.update(time)) {
            //  If the snake updated, we need to check for collision against food
            if (this.snake.collideWithFood(this.food)) {
                this.repositionFood();
                this.reward++;
            }
        }
    };
    /**
     * We can place the food anywhere in our 40x30 grid
     * *except* on-top of the snake, so we need
     * to filter those out of the possible food locations.
     * If there aren't any locations left, they've won!
     *
     * @method repositionFood
     * @return {boolean} true if the food was placed, otherwise false
     */
    SnakeGame.prototype.repositionFood = function () {
        //  First create an array that assumes all positions
        //  are valid for the new piece of food
        //  A Grid we'll use to reposition the food each time it's eaten
        var testGrid = [];
        for (var y = 0; y < this.gameHeight; y++) {
            testGrid[y] = [];
            for (var x = 0; x < this.gameWidth; x++) {
                testGrid[y][x] = true;
            }
        }
        this.snake.updateGrid(testGrid);
        //  Purge out false positions
        var validLocations = [];
        for (var y = 0; y < this.gameHeight; y++) {
            for (var x = 0; x < this.gameWidth; x++) {
                if (testGrid[y][x] === true) {
                    //  Is this position valid for food? If so, add it here ...
                    validLocations.push({ x: x, y: y });
                }
            }
        }
        if (validLocations.length > 0) {
            //  Use the RNG to pick a random food position
            var pos = Phaser.Math.RND.pick(validLocations);
            //  And place it
            this.food.setPosition(pos.x * 16, pos.y * 16);
            return true;
        }
        else {
            return false;
        }
    };
    return SnakeGame;
}(Phaser.Scene));
exports.default = SnakeGame;
