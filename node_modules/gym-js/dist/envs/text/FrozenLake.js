"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var discrete_1 = require("../../spaces/discrete");
var tf = require("@tensorflow/tfjs");
/**
 * An environment implementing the toy text "Frozen Lake" game.
 *
 * Actions:
 *  0. Up.
 *  1. Right.
 *  2. Down.
 *  3. Left.
 *
 * Rewards:
 *  - 1: If reach target 'G'.
 *  - 0: Otherwise.
 *
 * @example
 * ```typescript
 * import {FrozenLake} from "gym-js";
 * let mapSize=4,p=0.8,isSlippery=false;
 * const env = new FrozenLake(mapSize, p, isSlippery);
 *
 * console.log(env.action_space.toString());
 * > Discrete: 4    // 4 possible movements
 * console.log(env.observation_space.toString());
 * > Discrete: 16   // 4x4 map
 *
 * let action = env.action_space.sample();
 * let [obs, rew, done, info] = env.step(action);
 * ```
 */
var FrozenLake = /** @class */ (function () {
    /**
     * @param mapSize - The size of the map
     * @param p - The probability of not slipping
     * @param isSlippery - Set the ice to slippery or not. This makes the agent move
     * in a random direction with probability `1-p`.
     */
    function FrozenLake(mapSize, p, isSlippery) {
        if (mapSize === void 0) { mapSize = 4; }
        if (p === void 0) { p = 0.8; }
        if (isSlippery === void 0) { isSlippery = true; }
        this.action_space = new discrete_1.default([4]);
        this.reward_range = new discrete_1.default([2]);
        this.isSlippery = isSlippery;
        this.p = p;
        this.done = false;
        this.row = 0;
        this.col = 0;
        this.mustRender = false;
        if (mapSize === 8) {
            this.mapSize = mapSize;
            this.map = MAPS['8x8'];
        }
        else {
            this.mapSize = 4;
            this.map = MAPS['4x4'];
        }
        this.observation_space = new discrete_1.default([this.mapSize * this.mapSize]);
        //this.generateRandomMap(mapSize, p);
        this.observation_space.set(tf.tensor([0]));
    }
    FrozenLake.prototype.step = function (action) {
        var reward = 0;
        if (!this.done) {
            var newPos = this.move(this.row, this.col, action);
            this.row = newPos[0];
            this.col = newPos[1];
            var currentState = this.map[this.row][this.col];
            this.observation_space.set(this._toObs());
            if (currentState === 'H') {
                this.done = true;
                // reward = -1;
            }
            else if (currentState === 'G') {
                this.done = true;
                reward = 1;
            }
        }
        else {
            console.warn('This environment has terminated. You should call `reset` before continuing.');
        }
        this._callRender();
        return [this.observation_space.get(), reward, this.done, {}];
    };
    FrozenLake.prototype.reset = function () {
        this.done = false;
        this.observation_space.set(tf.tensor([0]));
        this.row = 0;
        this.col = 0;
        this._callRender();
        return this.observation_space.get();
    };
    /**
     * Set the environment to render to a particular output ("html" or "console").
     *
     * @param mode - To render in a particular mode - either "html" or "console".
     */
    FrozenLake.prototype.render = function (mode) {
        if (mode === void 0) { mode = "html"; }
        var renderModes = ["html", "console"];
        console.assert(renderModes.includes(mode), "Mode " + mode + " is not recognized, try any of " + renderModes.toString() + ".");
        this.mustRender = true;
        this.renderMode = mode;
    };
    FrozenLake.prototype._callRender = function () {
        var _this = this;
        if (this.mustRender) {
            if (this.renderMode === "html") {
                var currentObs_1 = this.observation_space.get().dataSync()[0];
                this.HTMLData = "<style>.currentState{background-color: red}</style>" +
                    this.map.map(function (row, rowId) { return ("<div>" + row.map(function (col, colId) { return ("<span" +
                        ((colId + (rowId * _this.mapSize) == currentObs_1) ? " class=\"currentState\"" : "") +
                        ">" + col + "</span>"); }).join("") + "</div>"); }).join("");
            }
            else if (this.renderMode === "console") {
                console.log(this.observation_space.get().dataSync());
            }
        }
    };
    FrozenLake.prototype.renderHTML = function () {
        return this.HTMLData;
    };
    FrozenLake.prototype.close = function () {
        console.clear();
        this.mustRender = false;
        this.HTMLData = "";
    };
    FrozenLake.prototype.seed = function (seed) { };
    FrozenLake.prototype.move = function (row, col, action) {
        if (this.isSlippery && Math.random() > 1 / 3) {
            action = this.action_space.sample();
        }
        if (this.inMap(row, col, action)) {
            if (action === Direction.Up) {
                row -= 1;
            }
            if (action === Direction.Down) {
                row += 1;
            }
            if (action === Direction.Right) {
                col += 1;
            }
            if (action === Direction.Left) {
                col -= 1;
            }
        }
        return [row, col];
    };
    // generateRandomMap(size = 8, p = 0.8) {}
    FrozenLake.prototype.inMap = function (row, col, action) {
        if (row === 0 && action === Direction.Up) {
            return false;
        }
        if (row === this.mapSize - 1 && action === Direction.Down) {
            return false;
        }
        if (col === 0 && action === Direction.Left) {
            return false;
        }
        if (col === this.mapSize - 1 && action === Direction.Right) {
            return false;
        }
        return true;
    };
    FrozenLake.prototype._toObs = function () {
        return tf.tensor([this.row * this.mapSize + this.col]);
    };
    return FrozenLake;
}());
exports.default = FrozenLake;
function demo() {
    var game = new FrozenLake(8, 0.8, false);
    game.reset();
    game.render();
    var done = false;
    var outerEnv = document.getElementById('game');
    window.setInterval(function () {
        if (!done) {
            // game.render();
            outerEnv.innerHTML = game.renderHTML();
            var action = game.action_space.sample();
            console.log(decodeAction(action));
            var stepInfo = game.step(action);
            done = stepInfo[2];
        }
        else {
            game.reset();
            done = false;
            console.log('Game terminated, resetting.');
            console.log('---------------------------');
        }
    }, 1000);
}
module.exports.demo = demo;
var Direction;
(function (Direction) {
    Direction[Direction["Up"] = 0] = "Up";
    Direction[Direction["Right"] = 1] = "Right";
    Direction[Direction["Left"] = 2] = "Left";
    Direction[Direction["Down"] = 3] = "Down";
})(Direction || (Direction = {}));
var MAPS = {
    '4x4': [['S', 'F', 'F', 'F'],
        ['F', 'H', 'F', 'H'],
        ['F', 'F', 'F', 'H'],
        ['H', 'F', 'F', 'G']],
    '8x8': [
        ['S', 'F', 'F', 'F', 'F', 'F', 'F', 'F'],
        ['F', 'F', 'F', 'F', 'F', 'F', 'F', 'F'],
        ['F', 'F', 'F', 'H', 'F', 'F', 'F', 'F'],
        ['F', 'F', 'F', 'F', 'F', 'H', 'F', 'F'],
        ['F', 'F', 'F', 'H', 'F', 'F', 'F', 'F'],
        ['F', 'H', 'H', 'F', 'F', 'F', 'H', 'F'],
        ['F', 'H', 'F', 'F', 'H', 'F', 'H', 'F'],
        ['F', 'F', 'F', 'H', 'F', 'F', 'F', 'G'],
    ],
};
/** Decode an action from the [[FrozenLake]] env for debugging. */
function decodeAction(action) {
    if (action === Direction.Up)
        return 'Up';
    if (action === Direction.Right)
        return 'Right';
    if (action === Direction.Left)
        return 'Left';
    if (action === Direction.Down)
        return 'Down';
    return 'Not in action space';
}
