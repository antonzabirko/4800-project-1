import Env from '../../core';
import Discrete, { DiscreteTuple } from '../../spaces/discrete';
import * as tf from '@tensorflow/tfjs';
declare type actionSpace = Discrete[] | number | number[];
/**
 * Abstract environment for algorithms.
 *
 * Action: A tuple containing [
 *  the move over the input,
 *  whether to write to the output,
 *  the predicted character
 * ]
 *
 * Observations: The character under the read cursor.
 *  A total of `base` + 1 with an extra out-of-bounds
 *  character.
 *
 * The environment terminates immediately when an incorrect item
 * is written or when the entire output is successfully outputted.
 */
declare abstract class AlgorithmicEnv implements Env {
    /**
     * @param movements The possible movements that the agent can make.
     * @param base Number of distinct characters.
     */
    constructor(movements: string[], base?: number);
    action_space: DiscreteTuple;
    observation_space: Discrete;
    reward_range: Discrete;
    base: number;
    MOVEMENTS: string[];
    MIN_LENGTH: number;
    charmap: string[];
    done: boolean;
    reward: number;
    target: [];
    cursor: number;
    inputData: any;
    agentActions: number[];
    targetLength: number;
    renderMode: string;
    mustRender: boolean;
    HTMLData: string;
    step(action: actionSpace): [tf.Tensor, number, boolean, {}];
    reset(): tf.Tensor;
    /**
     * Set the environment to render to a particular output ("html" or "console").
     *
     * @param mode - To render in a particular mode - either "html" or "console".
     */
    render(mode?: string): void;
    private _attemptRender;
    renderHTML(): string;
    close(): void;
    seed(seed: number): void;
    getStrObs(): string;
    abstract move(action: actionSpace): void;
    abstract toObs(): tf.Tensor;
    abstract setTarget(input_data: any): void;
    abstract genInputData(size: number): any;
}
/**
 * A 1 dimensional algorithmic env.
 *
 * Environment observations wrap around tape with an additional
 * observation for the out-of-bounds case.
 *
 * The `MIN_LENGTH` of the tape is `5` plus a random number between
 * 0 and 2.
 */
declare abstract class TapeAlgorithmicEnv extends AlgorithmicEnv {
    MOVEMENTS: string[];
    cursor: number;
    constructor(base?: number);
    move(action: actionSpace): void;
    toObs(): any;
    genInputData(size: number): any;
}
/**
 * A 2 dimensional algorithmic env.
 * Not tested yet.
 */
declare abstract class GridAlgorithmicEnv extends AlgorithmicEnv {
    constructor(rows: number, base?: number);
    MOVEMENTS: string[];
    rows: number;
    row: number;
    col: number;
    move(action: actionSpace): void;
    toObs(): tf.Tensor;
    genInputData(size: number): any;
}
/**
 * Decode the algorithmic env tuple action_space into an object containing
 * the decoded movement, write boolean, and the character to write.
 *
 * @param action An action in the `action_space` of the env.
 * @param movements The allowed movements of the env.
 */
declare function decodeAction(action: actionSpace, movements: string[]): {};
export { TapeAlgorithmicEnv, GridAlgorithmicEnv, decodeAction };
//# sourceMappingURL=AlgorithmicEnv.d.ts.map