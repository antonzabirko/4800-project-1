"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tf = require("@tensorflow/tfjs");
var utils_1 = require("../utils");
/**
 * A `Discrete` `Space` class.
 *
 * Used for spaces with a discrete sample space as opposed to continuous.
 *
 * @example
 * ```typescript
 * const disc = new Discrete([6]);
 * console.log(disc.toString());
 * > Discrete: [6]
 *
 * const sample = disc.sample();
 * console.log(sample);
 * > 2
 * ```
 */
var Discrete = /** @class */ (function () {
    /**
     * @param shape - The shape of the space
     */
    function Discrete(shape) {
        this.shape = shape;
        this.type = 'Discrete';
        this.length = Number(tf
            .tensor(this.shape)
            .prod()
            .arraySync()
            .valueOf());
        this.sampleSpace = tf.range(0, this.length).reshape(shape);
    }
    /**
     * Sample a random value from this `Space`.
     *
     * @returns - A random sample.
     */
    Discrete.prototype.sample = function () {
        // TODO: change to tensor?
        return utils_1.toNumLike(this.shape.map(function (v) { return utils_1.randint(v); }));
    };
    // Currently unused
    Discrete.prototype.seed = function (seed) {
        this.seedValue = seed;
    };
    Discrete.prototype.set = function (space) {
        this.sampleSpace = space;
    };
    Discrete.prototype.get = function () {
        return this.sampleSpace;
    };
    // contains(action: number){
    //   // if(typeof this.sampleSpace.arraySync() === number) return action === this.sampleSpace.arraySync();
    //   return this.sampleSpace.arraySync().includes(action);
    // }
    Discrete.prototype.toString = function () {
        return this.type + ': ' + this.shape.toString();
    };
    return Discrete;
}());
exports.default = Discrete;
/**
 * A tuple of [[Discrete]] Spaces.
 *
 * A convenience class for sampling a tuple of [[Discrete]] spaces.
 *
 * @example
 * ```typescript
 * const discTuple = new DiscreteTuple([2,2,6]);
 * console.log(discTuple.toString());
 * > DiscreteTuple: [2, 2, 6]
 *
 * const sample = discTuple.sample();
 * console.log(sample);
 * > [0,1,3]
 * ```
 */
var DiscreteTuple = /** @class */ (function () {
    /**
     * @param shape - The shape of the tuple.
     */
    function DiscreteTuple(shape) {
        this.shape = shape;
        this.type = 'DiscreteTuple';
        this.length = Number(tf
            .tensor(this.shape)
            .prod()
            .arraySync()
            .valueOf());
        this.setSampleSpace(shape);
    }
    DiscreteTuple.prototype.setSampleSpace = function (value) {
        this.sampleSpace = value.map(function (i) { return new Discrete([i]); });
    };
    /**
     * Sample a random value from this `Space`.
     *
     * @returns - A tuple of random samples.
     */
    DiscreteTuple.prototype.sample = function () {
        return utils_1.toArrayLike(this.sampleSpace.map(function (ss) { return ss.sample(); }));
    };
    // Currently unused
    DiscreteTuple.prototype.seed = function (seed) {
        this.seedValue = seed;
    };
    // These methods (get and set) are for observation spaces.
    // They shouldn't be implemented if the class
    // is only used for action spaces
    DiscreteTuple.prototype.set = function (space) {
        // assert contains(space)
        this.setSampleSpace(space.arraySync());
    };
    DiscreteTuple.prototype.get = function () {
        return tf.tensor(utils_1.toArrayLike(this.sampleSpace.map(function (i) { return i; })));
    };
    // contains(action: number){
    //   // if(typeof this.sampleSpace.arraySync() === number) return action === this.sampleSpace.arraySync();
    //   return this.sampleSpace.arraySync().includes(action);
    // }
    DiscreteTuple.prototype.toString = function () {
        return this.type + ': ' + this.shape.toString();
    };
    return DiscreteTuple;
}());
exports.DiscreteTuple = DiscreteTuple;
